{"version":3,"file":"index.js","sources":["../src/misc/timestamp-parser.ts","../src/misc/document-parser.ts","../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/logger.ts","../src/misc/logger/firestore-logger.ts","../src/misc/file-parser.ts","../src/misc/pathHelper.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/metadata-parser.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["export function parseAllDatesDoc(obj: any) {\r\n  const isObject = !!obj && typeof obj === 'object';\r\n  if (!isObject) {\r\n    return;\r\n  }\r\n  Object.keys(obj).map(key => {\r\n    const value = obj[key];\r\n    obj[key] = recusivelyCheckObjectValue(value);\r\n  });\r\n}\r\n\r\nexport function recusivelyCheckObjectValue(input: any): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as []).map(value => recusivelyCheckObjectValue(value));\r\n  }\r\n  const isObject = typeof input === 'object';\r\n  if (isObject) {\r\n    Object.keys(input).map(key => {\r\n      const value = input[key];\r\n      input[key] = recusivelyCheckObjectValue(value);\r\n    });\r\n    return input;\r\n  }\r\n}\r\n","import { QueryDocumentSnapshot } from '@firebase/firestore-types';\r\nimport { parseAllDatesDoc } from './timestamp-parser';\r\n\r\nexport const parseFireStoreDocument = (doc: QueryDocumentSnapshot) => {\r\n  const data = doc.data();\r\n  parseAllDatesDoc(data);\r\n  // React Admin requires an id field on every document,\r\n  // So we can just using the firestore document id\r\n  return { id: doc.id, ...data };\r\n};\r\n","import { get, isEmpty } from 'lodash';\r\nimport { getFieldReferences, SearchObj } from './objectFlatten';\r\n\r\nexport function sortArray(\r\n  data: Array<{}>,\r\n  field: string,\r\n  dir: 'asc' | 'desc'\r\n): void {\r\n  data.sort((a: {}, b: {}) => {\r\n    const rawA = get(a, field);\r\n    const rawB = get(b, field);\r\n    const isAsc = dir === \"asc\";\r\n\r\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\r\n    if (isNumberField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\r\n    if (isStringField) {\r\n      const aParsed = rawA.toLowerCase();\r\n      const bParsed = rawB.toLowerCase();\r\n      return basicSort(aParsed, bParsed, isAsc);\r\n    }\r\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\r\n    if (isDateField) {\r\n      return basicSort(rawA, rawB, isAsc);\r\n    }\r\n    return basicSort(!!rawA, !!rawB, isAsc);\r\n  });\r\n}\r\n\r\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\r\n  if (aValue > bValue) {\r\n    return isAsc ? 1 : -1;\r\n  }\r\n  if (aValue < bValue) {\r\n    return isAsc ? -1 : 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function filterArray(\r\n  data: Array<{}>,\r\n  searchFields?: { [field: string]: string | number | boolean | null }\r\n): Array<{}> {\r\n  if (!searchFields || isEmpty(searchFields)) {\r\n    return data;\r\n  }\r\n  const searchObjs: SearchObj[] = [];\r\n  Object.keys(searchFields).map((fieldName) => {\r\n    const fieldValue = searchFields[fieldName];\r\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\r\n    searchObjs.push(...getSubObjects);\r\n  });\r\n  const filtered = data.filter((row) =>\r\n    searchObjs.reduce((acc, cur) => {\r\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\r\n      return res && acc;\r\n    }, true as boolean)\r\n  );\r\n  return filtered;\r\n}\r\n\r\nexport function doesRowMatch(\r\n  row: {},\r\n  searchField: string,\r\n  searchValue: any\r\n): boolean {\r\n  const searchThis = get(row, searchField);\r\n  const bothAreFalsey = !searchThis && !searchValue;\r\n  if (bothAreFalsey) {\r\n    return true;\r\n  }\r\n  const nothingToSearch = !searchThis;\r\n  if (nothingToSearch) {\r\n    return false;\r\n  }\r\n  const isStringSearch = typeof searchValue === 'string';\r\n  if (isStringSearch) {\r\n    return searchThis\r\n      .toString()\r\n      .toLowerCase()\r\n      .includes(searchValue.toLowerCase());\r\n  }\r\n  const isBooleanOrNumber =\r\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\r\n  if (isBooleanOrNumber) {\r\n    return searchThis === searchValue;\r\n  }\r\n  return false;\r\n}\r\n","export interface SearchObj {\r\n  searchField: string;\r\n  searchValue: number | string | boolean | null;\r\n}\r\nexport function getFieldReferences(\r\n  fieldName: string,\r\n  value: {} | number | string | boolean | null\r\n): SearchObj[] {\r\n  const isFalsy = !value;\r\n  const isSimple = isFalsy ||\r\n    typeof value === 'string' ||\r\n    typeof value === 'number' ||\r\n    typeof value === 'boolean';\r\n\r\n  if (isSimple) {\r\n    return [\r\n      {\r\n        searchField: fieldName,\r\n        searchValue: value as number | string | boolean | null,\r\n      },\r\n    ];\r\n  }\r\n  const tree = {} as any;\r\n  tree[fieldName] = value;\r\n  return objectFlatten(tree);\r\n}\r\n\r\nexport function objectFlatten(tree: {}): SearchObj[] {\r\n  var leaves: SearchObj[] = [];\r\n  var recursivelyWalk = function (obj: any, path: string | null) {\r\n    path = path || \"\";\r\n    for (var key in obj) {\r\n      if (obj.hasOwnProperty(key)) {\r\n        const objVal = obj && obj[key];\r\n        const currentPath = !!path ? path + \".\" + key : key;\r\n        const isWalkable =\r\n          typeof objVal === 'object' || objVal instanceof Array;\r\n        if (isWalkable) {\r\n          recursivelyWalk(objVal, currentPath);\r\n        } else {\r\n          leaves.push({ searchField: currentPath, searchValue: objVal });\r\n        }\r\n      }\r\n    }\r\n  };\r\n  recursivelyWalk(tree, null);\r\n  return leaves;\r\n}\r\n","type LogFn = (...args: any) => void;\r\n\r\nexport const LogNoOp: LogFn = (...args: any) => null;\r\n\r\nexport class LoggerBase {\r\n  constructor(private title: string, private cacheEnabledKey: string) {}\r\n\r\n  private isEnabled() {\r\n    return !!localStorage.getItem(this.cacheEnabledKey);\r\n  }\r\n\r\n  SetEnabled(isEnabled: boolean) {\r\n    if (isEnabled) {\r\n      localStorage.setItem(this.cacheEnabledKey, 'true');\r\n    } else {\r\n      localStorage.removeItem(this.cacheEnabledKey);\r\n    }\r\n  }\r\n\r\n  public get log() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.log.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get warn() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.warn.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n\r\n  public get error() {\r\n    if (!this.isEnabled()) {\r\n      return LogNoOp;\r\n    }\r\n    const boundLogFn: (...args: any) => void = console.error.bind(\r\n      console,\r\n      this.title\r\n    );\r\n    return boundLogFn;\r\n  }\r\n}\r\n","import { LoggerBase } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\r\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\r\n\r\nexport const log = logger.log;\r\nexport const logError = logger.error;\r\nexport const logWarn = logger.warn;\r\n","import { RAFirebaseOptions } from 'providers/options';\r\nimport { LogNoOp, LoggerBase } from './logger-base';\r\n\r\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\r\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\r\n\r\nconst KEY_SINGLE = 'firecosts-single-reads';\r\n\r\nexport interface IFirestoreLogger {\r\n  logDocument: (count: number) => Function;\r\n  SetEnabled: (isEnabled: boolean) => void;\r\n  ResetCount: (shouldReset: boolean) => void;\r\n}\r\n\r\nexport function MakeFirestoreLogger(\r\n  options: RAFirebaseOptions\r\n): IFirestoreLogger {\r\n  function notEnabled() {\r\n    return !options?.lazyLoading?.enabled;\r\n  }\r\n\r\n  function incrementRead(incrementBy = 1) {\r\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\r\n    const currentCount = parseInt(currentCountRaw) || 0;\r\n    const incremented = currentCount + incrementBy;\r\n    localStorage.setItem(KEY_SINGLE, incremented + '');\r\n    return incremented;\r\n  }\r\n  function clearCache() {\r\n    localStorage.removeItem(KEY_SINGLE);\r\n  }\r\n  return {\r\n    SetEnabled(isEnabled: boolean) {\r\n      logger.SetEnabled(isEnabled);\r\n    },\r\n    ResetCount(shouldReset: boolean) {\r\n      shouldReset && clearCache()\r\n    },\r\n    logDocument(docCount: number) {\r\n      if (notEnabled()) {\r\n        return LogNoOp;\r\n      }\r\n      const count = incrementRead(docCount);\r\n      const suffix = `+${docCount} (session total=${count} documents read)`;\r\n      const boundLogFn: (...args: any) => void = logger.log.bind(\r\n        console,\r\n        suffix\r\n      );\r\n      return boundLogFn;\r\n    },\r\n  };\r\n}\r\n","import { logError } from './logger';\r\nimport { IFirebaseWrapper } from '../providers/database/firebase/IFirebaseWrapper';\r\n\r\ninterface ParsedUpload {\r\n  fieldDotsPath: string;\r\n  fieldSlashesPath: string;\r\n  rawFile: File | any;\r\n}\r\n\r\nexport function parseDocGetAllUploads(obj: any): ParsedUpload[] {\r\n  const isObject = !!obj && typeof obj === \"object\";\r\n  if (!isObject) {\r\n    return [];\r\n  }\r\n  const uploads: ParsedUpload[] = [];\r\n  Object.keys(obj).map((key) => {\r\n    const value = obj[key];\r\n    recusivelyParseObjectValue(value, key, uploads);\r\n  });\r\n  return uploads;\r\n}\r\n\r\nexport function recusivelyParseObjectValue(\r\n  input: any,\r\n  fieldPath: string,\r\n  uploads: ParsedUpload[]\r\n): any {\r\n  const isFalsey = !input;\r\n  if (isFalsey) {\r\n    return input;\r\n  }\r\n  const isPrimitive = typeof input !== 'object';\r\n  if (isPrimitive) {\r\n    return input;\r\n  }\r\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\r\n  if (isTimestamp) {\r\n    return input.toDate();\r\n  }\r\n  const isArray = Array.isArray(input);\r\n  if (isArray) {\r\n    return (input as []).map((value, index) =>\r\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, uploads)\r\n    );\r\n  }\r\n  const isObject = typeof input === 'object';\r\n  if (!isObject) {\r\n    return;\r\n  }\r\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\r\n  if (isFileField) {\r\n    uploads.push({\r\n      fieldDotsPath: fieldPath,\r\n      fieldSlashesPath: fieldPath.split('.').join('/'),\r\n      rawFile: input.rawFile\r\n    });\r\n    delete input.rawFile;\r\n    return;\r\n  }\r\n  Object.keys(input).map((key) => {\r\n    const value = input[key];\r\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, uploads);\r\n  });\r\n  return input;\r\n}\r\n\r\nexport const recursivelyMapStorageUrls = async (\r\n  fireWrapper: IFirebaseWrapper,\r\n  fieldValue: any\r\n): Promise<any> => {\r\n  const isArray = Array.isArray(fieldValue);\r\n  const isObject = !isArray && typeof fieldValue === \"object\";\r\n  const isFileField = isObject && !!fieldValue && fieldValue.hasOwnProperty(\"src\");\r\n  if (isFileField) {\r\n    const isAlreadyUploaded = fieldValue.src.startsWith('https://');\r\n    if (isAlreadyUploaded) {\r\n      return fieldValue;\r\n    }\r\n    let ref: firebase.storage.Reference = null as any;\r\n    try {\r\n      ref = fireWrapper.storage().ref(fieldValue.src);\r\n      const src = await ref.getDownloadURL();\r\n      return {\r\n        ...fieldValue,\r\n        src\r\n      };\r\n    } catch (error) {\r\n      logError(`Error when getting download URL`, {\r\n        error,\r\n        fieldValue,\r\n        ref\r\n      });\r\n      return fieldValue;\r\n    }\r\n  } else if (isObject) {\r\n    for (let key in fieldValue) {\r\n      if (fieldValue.hasOwnProperty(key)) {\r\n        const value = fieldValue[key];\r\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\r\n      }\r\n    }\r\n\r\n    return fieldValue;\r\n  } else if (isArray) {\r\n    for (let i = 0; i < fieldValue.length; i++) {\r\n      fieldValue[i] = await recursivelyMapStorageUrls(fireWrapper, fieldValue[i])\r\n    }\r\n\r\n    return fieldValue;\r\n  }\r\n\r\n  return fieldValue;\r\n};\r\n","import path from \"path-browserify\";\r\n\r\nexport function getAbsolutePath(\r\n  rootRef: undefined | string | (() => string),\r\n  relativePath: string | null\r\n): string {\r\n  if (!rootRef) {\r\n    return relativePath+'';\r\n  }\r\n  if (!relativePath) {\r\n    throw new Error(\r\n      \"Resource name must be a string of length greater than 0 characters\"\r\n    );\r\n  }\r\n  const rootRefValue = typeof rootRef === \"string\" ? rootRef : rootRef();\r\n  const withSlashes = path.join(\"/\", rootRefValue, \"/\", relativePath, \"/\");\r\n  const slashCount = withSlashes.split(\"/\").length - 1;\r\n  if (slashCount % 2) {\r\n    throw new Error(`The rootRef path must point to a \"document\"\r\n    not a \"collection\"e.g. /collection/document/ or\r\n    /collection/document/collection/document/`);\r\n  }\r\n  return withSlashes.slice(1, -1);\r\n}\r\n\r\nexport function joinPaths(...args: string[]) {\r\n  return path.join(...args);\r\n}\r\n","import { FireApp, IFirebaseWrapper } from './IFirebaseWrapper';\r\n\r\nimport firebase, { User } from 'firebase/app';\r\nimport 'firebase/firestore';\r\nimport { getFirestore } from '@firebase/firestore';\r\nimport 'firebase/auth';\r\nimport 'firebase/storage';\r\nimport { log } from 'misc';\r\nimport { RAFirebaseOptions } from 'providers/options';\r\n\r\nexport class FirebaseWrapper implements IFirebaseWrapper {\r\n  private firestore: firebase.firestore.Firestore = null as any;\r\n  private app: FireApp = null as any;\r\n  public options: RAFirebaseOptions = {};\r\n\r\n  public GetApp(): FireApp {\r\n    return this.app;\r\n  }\r\n\r\n  constructor() {}\r\n\r\n  public init(firebaseConfig: {}, options?: RAFirebaseOptions): void {\r\n    const optionsSafe = options || {};\r\n    this.options = optionsSafe;\r\n    this.app = ObtainFirebaseApp(firebaseConfig, optionsSafe);\r\n    this.firestore = firebase.firestore(this.app)\r\n  }\r\n  public db(): firebase.firestore.Firestore {\r\n    return this.firestore;\r\n  }\r\n  public serverTimestamp() {\r\n    // This line doesn't work for some reason, might be firebase sdk.\r\n    // return firebase.firestore.FieldValue.serverTimestamp();\r\n    return new Date();\r\n  }\r\n  public auth() {\r\n    return this.app.auth() as any;\r\n  }\r\n  public storage() {\r\n    return this.app.storage();\r\n  }\r\n  public async GetUserLogin(): Promise<User> {\r\n    return new Promise((resolve, reject) => {\r\n      this.app.auth().onAuthStateChanged((user) => {\r\n        if (user) {\r\n          resolve(user);\r\n        } else {\r\n          reject('getUserLogin() no user logged in');\r\n        }\r\n      });\r\n    });\r\n  }\r\n  public OnUserLogout(callBack: (u: firebase.User | null) => any) {\r\n    this.app.auth().onAuthStateChanged((user) => {\r\n      const isLoggedOut = !user;\r\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\r\n      if (isLoggedOut) {\r\n        callBack(user);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ObtainFirebaseApp(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): firebase.app.App {\r\n  if (options.app) {\r\n    return options.app;\r\n  }\r\n  const isInitialized = !!firebase.apps.length;\r\n  if (isInitialized) {\r\n    return firebase.app();\r\n  } else {\r\n    return firebase.initializeApp(firebaseConfig);\r\n  }\r\n}\r\n","// Firebase types\r\nimport {\r\n  CollectionReference,\r\n  QueryDocumentSnapshot,\r\n  FirebaseFirestore,\r\n} from '@firebase/firestore-types';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\r\nimport {\r\n  log,\r\n  getAbsolutePath,\r\n  messageTypes,\r\n  parseAllDatesDoc,\r\n  logWarn,\r\n  IFirestoreLogger,\r\n} from '../../misc';\r\n\r\nexport interface IResource {\r\n  path: string;\r\n  pathAbsolute: string;\r\n  collection: CollectionReference;\r\n  list: Array<{} & { deleted?: boolean }>;\r\n}\r\n\r\nexport class ResourceManager {\r\n  private resources: {\r\n    [resourceName: string]: IResource;\r\n  } = {};\r\n\r\n  private db: FirebaseFirestore;\r\n\r\n  constructor(\r\n    private fireWrapper: IFirebaseWrapper,\r\n    private options: RAFirebaseOptions,\r\n    private flogger: IFirestoreLogger\r\n  ) {\r\n    this.db = fireWrapper.db();\r\n\r\n    this.fireWrapper.OnUserLogout(() => {\r\n      this.resources = {};\r\n    });\r\n  }\r\n\r\n  public async TryGetResource(\r\n    resourceName: string,\r\n    refresh?: 'REFRESH',\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    if (refresh) {\r\n      await this.RefreshResource(resourceName, collectionQuery);\r\n    }\r\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n\r\n  public GetResource(relativePath: string): IResource {\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async TryGetResourcePromise(\r\n    relativePath: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    log('resourceManager.TryGetResourcePromise', {\r\n      relativePath,\r\n      collectionQuery,\r\n    });\r\n    await this.initPath(relativePath);\r\n\r\n    const resource: IResource = this.resources[relativePath];\r\n    if (!resource) {\r\n      throw new Error(\r\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\r\n      );\r\n    }\r\n    return resource;\r\n  }\r\n\r\n  public async RefreshResource(\r\n    relativePath: string,\r\n    collectionQuery: messageTypes.CollectionQueryType | undefined\r\n  ) {\r\n    if (this.options?.lazyLoading?.enabled) {\r\n      logWarn('resourceManager.RefreshResource', {\r\n        warn: 'RefreshResource is not available in lazy loading mode',\r\n      });\r\n      throw new Error(\r\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\r\n      );\r\n    }\r\n\r\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\r\n    await this.initPath(relativePath);\r\n    const resource = this.resources[relativePath];\r\n\r\n    const collection = resource.collection;\r\n    const query = this.applyQuery(collection, collectionQuery);\r\n    const newDocs = await query.get();\r\n\r\n    resource.list = newDocs.docs.map((doc) => this.parseFireStoreDocument(doc));\r\n    const count = newDocs.docs.length;\r\n    this.flogger.logDocument(count)();\r\n    log('resourceManager.RefreshResource', {\r\n      newDocs,\r\n      resource,\r\n      collectionPath: collection.path,\r\n    });\r\n  }\r\n\r\n  public async GetSingleDoc(relativePath: string, docId: string) {\r\n    await this.initPath(relativePath);\r\n    const resource = this.GetResource(relativePath);\r\n    this.flogger.logDocument(1)();\r\n    const docSnap = await resource.collection.doc(docId).get();\r\n    if (!docSnap.exists) {\r\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\r\n    }\r\n    const result = this.parseFireStoreDocument(docSnap as any);\r\n    log('resourceManager.GetSingleDoc', {\r\n      relativePath,\r\n      resource,\r\n      docId,\r\n      docSnap,\r\n      result,\r\n    });\r\n    return result;\r\n  }\r\n\r\n  private async initPath(relativePath: string): Promise<void> {\r\n    const rootRef = this.options && this.options.rootRef;\r\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\r\n    const hasBeenInited = !!this.resources[relativePath];\r\n    log('resourceManager.initPath()', {\r\n      absolutePath,\r\n      hasBeenInited,\r\n    });\r\n    if (hasBeenInited) {\r\n      log('resourceManager.initPath() has been initialized already...');\r\n      return;\r\n    }\r\n    const collection = this.db.collection(absolutePath);\r\n    const list: Array<{}> = [];\r\n    const resource: IResource = {\r\n      collection,\r\n      list,\r\n      path: relativePath,\r\n      pathAbsolute: absolutePath,\r\n    };\r\n    this.resources[relativePath] = resource;\r\n    log('resourceManager.initPath() setting resource...', {\r\n      resource,\r\n      allResources: this.resources,\r\n      collection: collection,\r\n      collectionPath: collection.path,\r\n    });\r\n  }\r\n\r\n  private parseFireStoreDocument(doc: QueryDocumentSnapshot | undefined): {} {\r\n    if (!doc) {\r\n      logWarn('parseFireStoreDocument: no doc', { doc });\r\n      return {};\r\n    }\r\n    const data = doc.data();\r\n    parseAllDatesDoc(data);\r\n    // React Admin requires an id field on every document,\r\n    // So we can just using the firestore document id\r\n    return { id: doc.id, ...data };\r\n  }\r\n\r\n  public async getUserIdentifier(): Promise<string> {\r\n    const identifier = this.options.associateUsersById\r\n      ? await this.getCurrentUserId()\r\n      : await this.getCurrentUserEmail();\r\n    return identifier;\r\n  }\r\n\r\n  private async getCurrentUserEmail() {\r\n    const user = await this.fireWrapper.GetUserLogin();\r\n    if (user) {\r\n      return user.email as string;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n  private async getCurrentUserId() {\r\n    const user = await this.fireWrapper.GetUserLogin();\r\n    if (user) {\r\n      return user.uid;\r\n    } else {\r\n      return 'annonymous user';\r\n    }\r\n  }\r\n\r\n  private applyQuery(\r\n    collection: CollectionReference,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): CollectionReference {\r\n    const collRef: CollectionReference = collectionQuery\r\n      ? collectionQuery(collection)\r\n      : collection;\r\n\r\n    log('resourceManager.applyQuery() ...', {\r\n      collection,\r\n      collectionQuery: (collectionQuery || '-').toString(),\r\n      collRef,\r\n    });\r\n    return collRef;\r\n  }\r\n}\r\n","import { set } from \"lodash\";\r\nimport {\r\n  AddCreatedByFields,\r\n  AddUpdatedByFields,\r\n  IFirestoreLogger,\r\n  joinPaths,\r\n  log,\r\n  logError,\r\n  parseDocGetAllUploads,\r\n} from \"../../misc\";\r\nimport { RAFirebaseOptions } from \"../options\";\r\nimport { IFirebaseWrapper } from \"./firebase/IFirebaseWrapper\";\r\nimport { IResource, ResourceManager } from \"./ResourceManager\";\r\n\r\nexport class FireClient {\r\n  public rm: ResourceManager;\r\n  public db() {\r\n    return this.fireWrapper.db();\r\n  }\r\n\r\n  constructor(\r\n    public fireWrapper: IFirebaseWrapper,\r\n    public options: RAFirebaseOptions,\r\n    public flogger: IFirestoreLogger\r\n  ) {\r\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\r\n  }\r\n\r\n  public checkRemoveIdField(obj: any, docId: string) {\r\n    if (!this.options.dontAddIdFieldToDoc) {\r\n      obj.id = docId;\r\n    }\r\n  }\r\n\r\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\r\n    if (!data) {\r\n      return data;\r\n    }\r\n    const docPath = r.collection.doc(id).path;\r\n\r\n    const uploads = parseDocGetAllUploads(data);\r\n    await Promise.all(\r\n      uploads.map(async (u) => {\r\n        const link = await this.uploadAndGetLink(\r\n          u.rawFile,\r\n          docPath,\r\n          u.fieldSlashesPath,\r\n          !!this.options.useFileNamesInStorage\r\n        );\r\n        set(data, u.fieldDotsPath + \".src\", link);\r\n      })\r\n    );\r\n    return data;\r\n  }\r\n\r\n  public async addCreatedByFields(obj: any) {\r\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  public async addUpdatedByFields(obj: any) {\r\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\r\n  }\r\n\r\n  private async uploadAndGetLink(\r\n    rawFile: any,\r\n    docPath: string,\r\n    fieldPath: string,\r\n    useFileName: boolean\r\n  ): Promise<string | undefined> {\r\n    const storagePath = useFileName\r\n      ? joinPaths(docPath, fieldPath, rawFile.name)\r\n      : joinPaths(docPath, fieldPath);\r\n    return this.saveFile(storagePath, rawFile);\r\n  }\r\n\r\n  private async saveFile(\r\n    storagePath: string,\r\n    rawFile: any\r\n  ): Promise<string | undefined> {\r\n    log(\"saveFile() saving file...\", { storagePath, rawFile });\r\n    const task = this.fireWrapper.storage().ref(storagePath).put(rawFile);\r\n    try {\r\n      const taskResult: firebase.storage.UploadTaskSnapshot = await new Promise(\r\n        (res, rej) => task.then(res).catch(rej)\r\n      );\r\n      const getDownloadURL = await taskResult.ref.getDownloadURL();\r\n      log(\"saveFile() saved file\", {\r\n        storagePath,\r\n        taskResult,\r\n        getDownloadURL,\r\n      });\r\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\r\n    } catch (storageError) {\r\n      if (storageError.code === \"storage/unknown\") {\r\n        logError(\r\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\r\n          { storageError }\r\n        );\r\n      } else {\r\n        logError(\"saveFile() error saving file\", {\r\n          storageError,\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { RAFirebaseOptions } from \"index\";\r\nimport { IFirebaseWrapper, ResourceManager } from \"providers/database\";\r\n\r\nexport async function AddCreatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | \"associateUsersById\"\r\n    | \"disableMeta\"\r\n    | \"renameMetaFields\"\r\n    | \"metaFieldCasing\"\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const createAtSelector = GetSelectorsCreateAt(options);\r\n  const createBySelector = GetSelectorsCreateBy(options);\r\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[createBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport async function AddUpdatedByFields(\r\n  obj: any,\r\n  fireWrapper: IFirebaseWrapper,\r\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\r\n  options: Pick<\r\n    RAFirebaseOptions,\r\n    | \"associateUsersById\"\r\n    | \"disableMeta\"\r\n    | \"renameMetaFields\"\r\n    | \"metaFieldCasing\"\r\n  >\r\n) {\r\n  if (options.disableMeta) {\r\n    return;\r\n  }\r\n  const currentUserIdentifier = await rm.getUserIdentifier();\r\n  const updateAtSelector = GetSelectorsUpdateAt(options);\r\n  const updateBySelector = GetSelectorsUpdateBy(options);\r\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\r\n  obj[updateBySelector] = currentUserIdentifier;\r\n}\r\n\r\nexport function GetSelectorsUpdateAt(\r\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\r\n    return options.renameMetaFields.updated_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = \"lastupdate\";\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === \"camel\") {\r\n    return \"lastUpdate\";\r\n  }\r\n  if (casing === \"snake\") {\r\n    return \"last_update\";\r\n  }\r\n  if (casing === \"pascal\") {\r\n    return \"LastUpdate\";\r\n  }\r\n  if (casing === \"kebab\") {\r\n    return \"last-update\";\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsUpdateBy(\r\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\r\n    return options.renameMetaFields.updated_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = \"updatedby\";\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === \"camel\") {\r\n    return \"updatedBy\";\r\n  }\r\n  if (casing === \"snake\") {\r\n    return \"updated_by\";\r\n  }\r\n  if (casing === \"pascal\") {\r\n    return \"UpdatedBy\";\r\n  }\r\n  if (casing === \"kebab\") {\r\n    return \"updated-by\";\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateAt(\r\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\r\n    return options.renameMetaFields.created_at;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = \"createdate\";\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === \"camel\") {\r\n    return \"createDate\";\r\n  }\r\n  if (casing === \"snake\") {\r\n    return \"create_date\";\r\n  }\r\n  if (casing === \"pascal\") {\r\n    return \"CreateDate\";\r\n  }\r\n  if (casing === \"kebab\") {\r\n    return \"create-date\";\r\n  }\r\n  return defautCase;\r\n}\r\n\r\nexport function GetSelectorsCreateBy(\r\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\r\n): string {\r\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\r\n    return options.renameMetaFields.created_by;\r\n  }\r\n  const casing = options.metaFieldCasing;\r\n  const defautCase = \"createdby\";\r\n  if (!casing) {\r\n    return defautCase;\r\n  }\r\n  if (casing === \"camel\") {\r\n    return \"createdBy\";\r\n  }\r\n  if (casing === \"snake\") {\r\n    return \"created_by\";\r\n  }\r\n  if (casing === \"pascal\") {\r\n    return \"CreatedBy\";\r\n  }\r\n  if (casing === \"kebab\") {\r\n    return \"created-by\";\r\n  }\r\n  return defautCase;\r\n}\r\n","import {\r\n  CollectionReference,\r\n  DocumentSnapshot,\r\n  Query,\r\n} from '@firebase/firestore-types';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\n\r\nexport function setQueryCursor(\r\n  doc: DocumentSnapshot,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string\r\n) {\r\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\r\n  localStorage.setItem(key, doc.id);\r\n\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (!localCursorKeys) {\r\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\r\n  } else {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    const newCursors = cursors.concat(key);\r\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\r\n  }\r\n}\r\n\r\nexport async function getQueryCursor(\r\n  collection: CollectionReference,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<DocumentSnapshot | false> {\r\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\r\n  const docId = localStorage.getItem(key);\r\n  if (!docId) {\r\n    return false;\r\n  }\r\n\r\n  const doc = await collection.doc(docId).get();\r\n  flogger.logDocument(1)();\r\n  if (doc.exists) {\r\n    // incrementFirebaseReadsCounter(1);\r\n    return doc;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function clearQueryCursors(resourceName: string) {\r\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\r\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\r\n  if (localCursorKeys) {\r\n    const cursors: string[] = JSON.parse(localCursorKeys);\r\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\r\n    localStorage.removeItem(allCursorsKey);\r\n  }\r\n}\r\n\r\nexport async function findLastQueryCursor(\r\n  collection: CollectionReference,\r\n  queryBase: Query,\r\n  params: messageTypes.IParamsGetList,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n) {\r\n  const { page, perPage } = params.pagination;\r\n\r\n  let lastQueryCursor: DocumentSnapshot | false = false;\r\n  let currentPage = page - 1;\r\n\r\n  const currentPageParams = {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n    },\r\n  };\r\n  while (!lastQueryCursor && currentPage > 1) {\r\n    currentPage--;\r\n    currentPageParams.pagination.page = currentPage;\r\n    console.log('getting query cursor currentPage=', currentPage);\r\n    lastQueryCursor = await getQueryCursor(\r\n      collection,\r\n      currentPageParams,\r\n      resourceName,\r\n      flogger\r\n    );\r\n  }\r\n  const limit = (page - currentPage) * perPage;\r\n  const isFirst = currentPage === 1;\r\n\r\n  function getQuery() {\r\n    if (isFirst) {\r\n      return queryBase.limit(limit);\r\n    } else {\r\n      return queryBase.startAt(lastQueryCursor).limit(limit);\r\n    }\r\n  }\r\n\r\n  const newQuery = getQuery();\r\n  const snapshots = await newQuery.get();\r\n  const docsLength = snapshots.docs.length;\r\n  flogger.logDocument(docsLength)();\r\n  const lastDocIndex = docsLength - 1;\r\n  const lastDocRef = snapshots.docs[lastDocIndex];\r\n  return lastDocRef;\r\n}\r\n","import {\r\n  CollectionReference,\r\n  OrderByDirection,\r\n  Query,\r\n} from '@firebase/firestore-types';\r\nimport { IFirestoreLogger, messageTypes } from '../../misc';\r\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\r\n\r\ninterface ParamsToQueryOptions {\r\n  filters?: boolean;\r\n  sort?: boolean;\r\n  pagination?: boolean;\r\n}\r\n\r\nconst defaultParamsToQueryOptions = {\r\n  filters: true,\r\n  sort: true,\r\n  pagination: true,\r\n};\r\n\r\nexport async function paramsToQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(\r\n  collection: CollectionReference,\r\n  params: TParams,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger,\r\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\r\n): Promise<Query> {\r\n  const filtersStepQuery = options.filters\r\n    ? filtersToQuery(collection, params.filter)\r\n    : collection;\r\n\r\n  const sortStepQuery = options.sort\r\n    ? sortToQuery(filtersStepQuery, params.sort)\r\n    : filtersStepQuery;\r\n\r\n  return options.pagination\r\n    ? paginationToQuery(\r\n        sortStepQuery,\r\n        params,\r\n        collection,\r\n        resourceName,\r\n        flogger\r\n      )\r\n    : sortStepQuery;\r\n}\r\n\r\nexport function filtersToQuery(\r\n  query: Query,\r\n  filters: { [fieldName: string]: any }\r\n): Query {\r\n  Object.keys(filters).forEach((fieldName) => {\r\n    query = query.where(fieldName, '==', filters[fieldName]);\r\n  });\r\n  return query;\r\n}\r\n\r\nexport function sortToQuery(\r\n  query: Query,\r\n  sort: { field: string; order: string }\r\n): Query {\r\n  if (sort != null && sort.field !== 'id') {\r\n    const { field, order } = sort;\r\n    const parsedOrder = order.toLocaleLowerCase() as OrderByDirection;\r\n    query = query.orderBy(field, parsedOrder);\r\n  }\r\n  return query;\r\n}\r\n\r\nasync function paginationToQuery<TParams extends messageTypes.IParamsGetList>(\r\n  query: Query,\r\n  params: TParams,\r\n  collection: CollectionReference,\r\n  resourceName: string,\r\n  flogger: IFirestoreLogger\r\n): Promise<Query> {\r\n  const { page, perPage } = params.pagination;\r\n  if (page === 1) {\r\n    query = query.limit(perPage);\r\n  } else {\r\n    let queryCursor = await getQueryCursor(\r\n      collection,\r\n      params,\r\n      resourceName,\r\n      flogger\r\n    );\r\n    if (!queryCursor) {\r\n      queryCursor = await findLastQueryCursor(\r\n        collection,\r\n        query,\r\n        params,\r\n        resourceName,\r\n        flogger\r\n      );\r\n    }\r\n    query = query.startAfter(queryCursor).limit(perPage);\r\n  }\r\n\r\n  return query;\r\n}\r\n\r\nexport function getFullParamsForQuery<\r\n  TParams extends messageTypes.IParamsGetList\r\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\r\n  return {\r\n    ...reactAdminParams,\r\n    filter: softdeleteEnabled\r\n      ? {\r\n          deleted: false,\r\n          ...reactAdminParams.filter,\r\n        }\r\n      : reactAdminParams.filter,\r\n  };\r\n}\r\n\r\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\r\n  params: TParams\r\n): TParams {\r\n  return {\r\n    ...params,\r\n    pagination: {\r\n      ...params.pagination,\r\n      page: params.pagination.page + 1,\r\n    },\r\n  };\r\n}\r\n","import {\r\n  log,\r\n  messageTypes,\r\n  parseFireStoreDocument,\r\n  recursivelyMapStorageUrls,\r\n} from '../../misc';\r\nimport {\r\n  CollectionReference,\r\n  DocumentSnapshot,\r\n} from '@firebase/firestore-types';\r\nimport { IResource, ResourceManager } from '../database/ResourceManager';\r\nimport { RAFirebaseOptions } from '../options';\r\nimport * as ra from '../../misc/react-admin-models';\r\nimport {\r\n  getFullParamsForQuery,\r\n  getNextPageParams,\r\n  paramsToQuery,\r\n} from './paramsToQuery';\r\nimport { clearQueryCursors, setQueryCursor } from './queryCursors';\r\nimport { FireClient } from 'providers/database';\r\n\r\nexport class FirebaseLazyLoadingClient {\r\n  constructor(\r\n    private readonly options: RAFirebaseOptions,\r\n    private readonly rm: ResourceManager,\r\n    private client: FireClient\r\n  ) {}\r\n\r\n  public async apiGetList<T extends ra.Record>(\r\n    resourceName: string,\r\n    reactAdminParams: ra.GetListParams\r\n  ): Promise<ra.GetListResult<T>> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    const params = getFullParamsForQuery(\r\n      reactAdminParams,\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    log('apiGetListLazy', { resourceName, params });\r\n\r\n    const query = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await query.get();\r\n\r\n    const resultsCount = snapshots.docs.length;\r\n    if (!resultsCount) {\r\n      log('apiGetListLazy', {\r\n        message: 'There are not records for given query',\r\n      });\r\n      return { data: [], total: 0 };\r\n    }\r\n    this.client.flogger.logDocument(resultsCount)();\r\n\r\n    const data = snapshots.docs.map(parseFireStoreDocument) as T[];\r\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\r\n    // After fetching documents save queryCursor for next page\r\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\r\n    // Hardcoded to allow next pages, as we don't have total number of items\r\n    let total = 9000;\r\n\r\n    // Check for next pages\r\n    // If it's last page, we can count all items and disable going to next page\r\n    const isOnLastPage = await this.checkIfOnLastPage(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      nextPageCursor\r\n    );\r\n\r\n    if (isOnLastPage) {\r\n      const { page, perPage } = params.pagination;\r\n      total = (page - 1) * perPage + data.length;\r\n      log('apiGetListLazy', { message: \"It's last page of collection.\" });\r\n    }\r\n\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetListLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total,\r\n      };\r\n    }\r\n\r\n    log('apiGetListLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n\r\n    return { data, total };\r\n  }\r\n\r\n  public async apiGetManyReference(\r\n    resourceName: string,\r\n    reactAdminParams: messageTypes.IParamsGetManyReference\r\n  ): Promise<messageTypes.IResponseGetManyReference> {\r\n    const r = await this.tryGetResource(resourceName);\r\n    log('apiGetManyReferenceLazy', {\r\n      resourceName,\r\n      resource: r,\r\n      reactAdminParams,\r\n    });\r\n    const filterWithTarget = {\r\n      ...reactAdminParams.filter,\r\n      [reactAdminParams.target]: reactAdminParams.id,\r\n    };\r\n    const params = getFullParamsForQuery(\r\n      {\r\n        ...reactAdminParams,\r\n        filter: filterWithTarget,\r\n      },\r\n      !!this.options.softDelete\r\n    );\r\n\r\n    const query = await paramsToQuery(\r\n      r.collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger\r\n    );\r\n\r\n    const snapshots = await query.get();\r\n    const resultsCount = snapshots.docs.length;\r\n    this.client.flogger.logDocument(resultsCount)();\r\n    const data = snapshots.docs.map(parseFireStoreDocument);\r\n    if (this.options.relativeFilePaths) {\r\n      const parsedData = await Promise.all(\r\n        data.map(async (doc: any) => {\r\n          for (let fieldName in doc) {\r\n            doc[fieldName] = await recursivelyMapStorageUrls(\r\n              this.client.fireWrapper,\r\n              doc[fieldName]\r\n            );\r\n          }\r\n          return doc;\r\n        })\r\n      );\r\n\r\n      log('apiGetManyReferenceLazy result', {\r\n        docs: parsedData,\r\n        resource: r,\r\n        collectionPath: r.collection.path,\r\n      });\r\n\r\n      return {\r\n        data: parsedData,\r\n        total: data.length,\r\n      };\r\n    }\r\n\r\n    log('apiGetManyReferenceLazy result', {\r\n      docs: data,\r\n      resource: r,\r\n      collectionPath: r.collection.path,\r\n    });\r\n    return { data, total: data.length };\r\n  }\r\n\r\n  private async checkIfOnLastPage<TParams extends messageTypes.IParamsGetList>(\r\n    collection: CollectionReference,\r\n    params: TParams,\r\n    resourceName: string,\r\n    nextPageCursor: DocumentSnapshot\r\n  ): Promise<boolean> {\r\n    const query = await paramsToQuery(\r\n      collection,\r\n      params,\r\n      resourceName,\r\n      this.client.flogger,\r\n      {\r\n        filters: true,\r\n        sort: true,\r\n      }\r\n    );\r\n    if (!nextPageCursor) {\r\n      throw new Error('Page cursor was empty...');\r\n    }\r\n    const nextElementSnapshot = await query\r\n      .startAfter(nextPageCursor)\r\n      .limit(1)\r\n      .get();\r\n\r\n    if (!nextElementSnapshot.empty) {\r\n      // this.incrementFirebaseReadsCounter(1);\r\n    }\r\n\r\n    return nextElementSnapshot.empty;\r\n  }\r\n\r\n  public clearQueryCursors(resourceName: string) {\r\n    clearQueryCursors(resourceName);\r\n  }\r\n\r\n  private async tryGetResource(\r\n    resourceName: string,\r\n    collectionQuery?: messageTypes.CollectionQueryType\r\n  ): Promise<IResource> {\r\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\r\n  }\r\n}\r\n","import { messageTypes } from './../misc/messageTypes';\r\nimport firebase from 'firebase/app';\r\nimport 'firebase/auth';\r\nimport { FirebaseAuth, User } from '@firebase/auth-types';\r\nimport { log, retrieveStatusTxt, logWarn, logger } from '../misc';\r\nimport { RAFirebaseOptions } from './options';\r\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\r\nimport {\r\n  AuthProvider as RaAuthProvider,\r\n  UserIdentity,\r\n} from '../misc/react-admin-models';\r\n\r\nclass AuthClient {\r\n  private auth: FirebaseAuth;\r\n\r\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\r\n    const options = optionsInput || {};\r\n    log('Auth Client: initializing...', { firebaseConfig, options });\r\n    const fireWrapper = new FirebaseWrapper();\r\n    fireWrapper.init(firebaseConfig, options);\r\n    this.auth = fireWrapper.auth();\r\n    options.persistence && this.setPersistence(options.persistence);\r\n  }\r\n\r\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\r\n    let persistenceResolved: string;\r\n    switch (persistenceInput) {\r\n      case 'local':\r\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\r\n        break;\r\n      case 'none':\r\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\r\n        break;\r\n      case 'session':\r\n      default:\r\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\r\n        break;\r\n    }\r\n    log('setPersistence', { persistenceInput, persistenceResolved });\r\n    this.auth\r\n      .setPersistence(persistenceResolved)\r\n      .catch((error) => console.error(error));\r\n  }\r\n\r\n  public async HandleAuthLogin(params: { username: string; password: string }) {\r\n    const { username, password } = params;\r\n\r\n    if (username && password) {\r\n      try {\r\n        const user = await this.auth.signInWithEmailAndPassword(\r\n          username,\r\n          password\r\n        );\r\n        log('HandleAuthLogin: user sucessfully logged in', { user });\r\n        return user;\r\n      } catch (e) {\r\n        log('HandleAuthLogin: invalid credentials', { params });\r\n        throw new Error('Login error: invalid credentials');\r\n      }\r\n    } else {\r\n      return this.getUserLogin();\r\n    }\r\n  }\r\n\r\n  public HandleAuthLogout() {\r\n    return this.auth.signOut();\r\n  }\r\n\r\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\r\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\r\n    const status = !!errorHttp && errorHttp.status;\r\n    const statusTxt = retrieveStatusTxt(status);\r\n    if (statusTxt === 'ok') {\r\n      log('API is actually authenticated');\r\n      return Promise.resolve();\r\n    }\r\n    logWarn('Recieved authentication error from API');\r\n    return Promise.reject();\r\n  }\r\n\r\n  public async HandleAuthCheck(): Promise<void> {\r\n    return this.getUserLogin() as any; // Prevents breaking change\r\n  }\r\n\r\n  public getUserLogin(): Promise<User> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.auth.currentUser) return resolve(this.auth.currentUser);\r\n      const unsubscribe = this.auth.onAuthStateChanged((user) => {\r\n        unsubscribe();\r\n        if (user) {\r\n          resolve(user);\r\n        } else {\r\n          reject();\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  public async HandleGetPermissions() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.claims;\r\n    } catch (e) {\r\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetIdentity(): Promise<UserIdentity> {\r\n    try {\r\n      const { uid, displayName, photoURL } = await this.getUserLogin();\r\n      const identity: UserIdentity = {\r\n        id: uid,\r\n        fullName: `${displayName ?? ''}`,\r\n        avatar: `${photoURL ?? ''}`,\r\n      };\r\n      return identity;\r\n    } catch (e) {\r\n      log('HandleGetIdentity: no user is logged in', {\r\n        e,\r\n      });\r\n      return null as any;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTAuthTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.authTime;\r\n    } catch (e) {\r\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\r\n        e,\r\n      });\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTExpirationTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.expirationTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTSignInProvider() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.signInProvider;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTIssuedAtTime() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.issuedAtTime;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n\r\n  public async HandleGetJWTToken() {\r\n    try {\r\n      const user = await this.getUserLogin();\r\n      // @ts-ignore\r\n      const token = await user.getIdTokenResult();\r\n\r\n      return token.token;\r\n    } catch (e) {\r\n      log(\r\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\r\n        {\r\n          e,\r\n        }\r\n      );\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\nexport function AuthProvider(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n): RaAuthProvider {\r\n  VerifyAuthProviderArgs(firebaseConfig, options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  const auth = new AuthClient(firebaseConfig, options);\r\n\r\n  const provider: RaAuthProvider = {\r\n    // React Admin Interface\r\n    login: (params) => auth.HandleAuthLogin(params),\r\n    logout: () => auth.HandleAuthLogout(),\r\n    checkAuth: () => auth.HandleAuthCheck(),\r\n    checkError: (error) => auth.HandleAuthError(error),\r\n    getPermissions: () => auth.HandleGetPermissions(),\r\n    getIdentity: () => auth.HandleGetIdentity(),\r\n    // Custom Functions\r\n    getAuthUser: () => auth.getUserLogin(),\r\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\r\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\r\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\r\n    getJWTClaims: () => auth.HandleGetPermissions(),\r\n    getJWTToken: () => auth.HandleGetJWTToken(),\r\n  };\r\n  return provider;\r\n}\r\n\r\nfunction VerifyAuthProviderArgs(\r\n  firebaseConfig: {},\r\n  options: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n}\r\n","// From firebase SDK\r\n\r\nimport { logError } from \"./logger\";\r\n\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\r\n  // Make sure any successful status is OK.\r\n  if (status >= 200 && status < 300) {\r\n    return 'ok';\r\n  }\r\n  switch (status) {\r\n    case 401: // 'unauthenticated'\r\n    case 403: // 'permission-denied'\r\n      return 'unauthenticated';\r\n\r\n    case 0: // 'internal'\r\n    case 400: // 'invalid-argument'\r\n    case 404: // 'not-found'\r\n    case 409: // 'aborted'\r\n    case 429: // 'resource-exhausted'\r\n    case 499: // 'cancelled'\r\n    case 500: // 'internal'\r\n    case 501: // 'unimplemented'\r\n    case 503: // 'unavailable'\r\n    case 504: // 'deadline-exceeded'\r\n    default:\r\n      // ignore\r\n      return 'ok';\r\n  }\r\n}\r\n\r\n// From firebase SDK\r\n// tslint:disable-next-line:max-line-length\r\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\r\nexport function retrieveStatusCode(statusTxt: string): number {\r\n  // Make sure any successful status is OK.\r\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\r\n  const status = Array.isArray(regexResult) && regexResult[1];\r\n  if (!status) {\r\n    logError('unknown StatusCode ', {statusTxt});\r\n  }\r\n  switch (status) {\r\n    case 'unauthenticated':\r\n      return 401;\r\n    case 'permission-denied':\r\n      return 403;\r\n    case 'internal':\r\n      return 0;\r\n    case 'invalid-argument':\r\n      return 400;\r\n    case 'not-found':\r\n      return 404;\r\n    case 'aborted':\r\n      return 409;\r\n    case 'resource-exhausted':\r\n      return 429;\r\n    case 'cancelled':\r\n      return 499;\r\n    case 'internal':\r\n      return 500;\r\n    case 'unimplemented':\r\n      return 501;\r\n    case 'unavailable':\r\n      return 503;\r\n    case 'deadline-exceeded':\r\n      return 504;\r\n    default:\r\n      return 200;\r\n  }\r\n}\r\n","import {\r\n  getAbsolutePath,\r\n  log,\r\n  logger,\r\n  retrieveStatusCode,\r\n  logError,\r\n  MakeFirestoreLogger,\r\n} from \"../misc\";\r\nimport * as ra from \"../misc/react-admin-models\";\r\nimport { RAFirebaseOptions } from \"./options\";\r\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\r\nimport { FireApp } from \"./database/firebase/IFirebaseWrapper\";\r\nimport { FireClient } from \"./database/FireClient\";\r\nimport { GetList, GetMany, GetManyReference, GetOne } from \"./queries\";\r\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from \"./commands\";\r\n\r\nexport interface IDataProvider extends ra.DataProvider {\r\n  app: FireApp;\r\n}\r\n\r\nexport function DataProvider(\r\n  firebaseConfig: {},\r\n  optionsInput?: RAFirebaseOptions\r\n): IDataProvider {\r\n  const options = optionsInput || {};\r\n  verifyDataProviderArgs(firebaseConfig, options);\r\n\r\n  const flogger = MakeFirestoreLogger(options);\r\n  logger.SetEnabled(!!options?.logging);\r\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\r\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\r\n  log('Creating FirebaseDataProvider', {\r\n    firebaseConfig,\r\n    options\r\n  });\r\n\r\n  const fireWrapper = new FirebaseWrapper();\r\n  fireWrapper.init(firebaseConfig, optionsInput);\r\n\r\n  async function run<T>(cb: () => Promise<T>) {\r\n    let res: any;\r\n    try {\r\n      res = await cb();\r\n      return res;\r\n    } catch (error) {\r\n      const errorMsg = error.toString();\r\n      const code = retrieveStatusCode(errorMsg);\r\n      const errorObj = { status: code, message: errorMsg, json: res };\r\n      logError(\"DataProvider:\", error, { errorMsg, code, errorObj });\r\n      throw errorObj;\r\n    }\r\n  }\r\n  const client = new FireClient(fireWrapper, options, flogger);\r\n\r\n  const newProviderApi: IDataProvider = {\r\n    app: fireWrapper.GetApp(),\r\n    getList<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetListParams\r\n    ): Promise<ra.GetListResult<RecordType>> {\r\n      return run(() => GetList<RecordType>(resource, params, client));\r\n    },\r\n    getOne<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetOneParams\r\n    ): Promise<ra.GetOneResult<RecordType>> {\r\n      return run(() => GetOne<RecordType>(resource, params, client));\r\n    },\r\n    getMany<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyParams\r\n    ): Promise<ra.GetManyResult<RecordType>> {\r\n      return run(() => GetMany<RecordType>(resource, params, client));\r\n    },\r\n    getManyReference<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.GetManyReferenceParams\r\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\r\n      return run(() =>\r\n        GetManyReference<RecordType>(resource, params, client)\r\n      );\r\n    },\r\n    update<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.UpdateParams\r\n    ): Promise<ra.UpdateResult<RecordType>> {\r\n      return run(() => Update<RecordType>(resource, params, client));\r\n    },\r\n    updateMany(\r\n      resource: string,\r\n      params: ra.UpdateManyParams\r\n    ): Promise<ra.UpdateManyResult> {\r\n      return run(() => UpdateMany(resource, params, client));\r\n    },\r\n    create<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.CreateParams\r\n    ): Promise<ra.CreateResult<RecordType>> {\r\n      return run(() => Create<RecordType>(resource, params, client));\r\n    },\r\n    delete<RecordType extends ra.Record = ra.Record>(\r\n      resource: string,\r\n      params: ra.DeleteParams\r\n    ): Promise<ra.DeleteResult<RecordType>> {\r\n      return run(() => Delete(resource, params, client));\r\n    },\r\n    deleteMany(\r\n      resource: string,\r\n      params: ra.DeleteManyParams\r\n    ): Promise<ra.DeleteManyResult> {\r\n      return run(() => DeleteMany(resource, params, client));\r\n    },\r\n  };\r\n\r\n  return newProviderApi;\r\n}\r\n\r\nfunction verifyDataProviderArgs(\r\n  firebaseConfig: {},\r\n  options?: RAFirebaseOptions\r\n) {\r\n  const hasNoApp = !options || !options.app;\r\n  const hasNoConfig = !firebaseConfig;\r\n  if (hasNoConfig && hasNoApp) {\r\n    throw new Error(\r\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\r\n    );\r\n  }\r\n  if (options && options.rootRef) {\r\n    // Will throw error if rootRef doesn't point to a document\r\n    getAbsolutePath(options.rootRef, 'test');\r\n  }\r\n}\r\n","import { FireClient } from '../database/FireClient';\r\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\r\nimport {\r\n  filterArray,\r\n  log,\r\n  recursivelyMapStorageUrls,\r\n  sortArray,\r\n} from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\n\r\nexport async function GetList<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetListParams,\r\n  client: FireClient\r\n): Promise<ra.GetListResult<T>> {\r\n  log('GetList', { resourceName, params });\r\n  const { rm, fireWrapper, options } = client;\r\n\r\n  if (options?.lazyLoading?.enabled) {\r\n    const lazyClient = new FirebaseLazyLoadingClient(\r\n      options,\r\n      rm,\r\n      client\r\n    );\r\n    return lazyClient.apiGetList<T>(resourceName, params);\r\n  }\r\n\r\n  const filterSafe = params.filter || {};\r\n\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  delete filterSafe.collectionQuery;\r\n\r\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\r\n  const data = r.list;\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === 'ASC') {\r\n      sortArray(data, field, 'asc');\r\n    } else {\r\n      sortArray(data, field, 'desc');\r\n    }\r\n  }\r\n  let softDeleted = data;\r\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\r\n    softDeleted = data.filter((doc) => !doc.deleted);\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\r\n  const total = filteredData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const data = await Promise.all(\r\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return {\r\n      data,\r\n      total,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: dataPage,\r\n    total,\r\n  };\r\n}\r\n","import { FireClient } from '../database/FireClient';\r\nimport { log, recursivelyMapStorageUrls } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\n\r\nexport async function GetOne<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetOneParams,\r\n  client: FireClient\r\n): Promise<ra.GetOneResult<T>> {\r\n  log('GetOne', { resourceName, params });\r\n  const { rm, fireWrapper } = client;\r\n  try {\r\n    const id = params.id + '';\r\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\r\n    client.flogger.logDocument(1)();\r\n    const data = await recursivelyMapStorageUrls(fireWrapper, dataSingle);\r\n    return { data: data };\r\n  } catch (error) {\r\n    throw new Error(\r\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\r\n    );\r\n  }\r\n}\r\n","import { FireClient } from '../database/FireClient';\r\nimport { log, recursivelyMapStorageUrls } from '../../misc';\r\nimport * as ra from '../../misc/react-admin-models';\r\n\r\nexport async function GetMany<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log('GetMany', { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const matchDocSnaps = await Promise.all(\r\n    ids.map((id) => r.collection.doc(id + '').get())\r\n  );\r\n  client.flogger.logDocument(ids.length)();\r\n  const matches = matchDocSnaps.map((snap) => {\r\n    return { ...snap.data(), id: snap.id } as T;\r\n  });\r\n  const permittedData = options.softDelete\r\n    ? matches.filter((row) => !row['deleted'])\r\n    : matches;\r\n  if (options.relativeFilePaths) {\r\n    const data = await Promise.all(\r\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\r\n    );\r\n    return {\r\n      data,\r\n    };\r\n  }\r\n\r\n  return {\r\n    data: permittedData,\r\n  };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { filterArray, log, recursivelyMapStorageUrls, sortArray } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\n\r\nexport async function GetManyReference<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.GetManyReferenceParams,\r\n  client: FireClient\r\n): Promise<ra.GetManyReferenceResult<T>> {\r\n  const { rm, options, fireWrapper } = client;\r\n  log(\"GetManyReference\", { resourceName, params });\r\n  const filterSafe = params.filter || {};\r\n  const collectionQuery = filterSafe.collectionQuery;\r\n  const r = await rm.TryGetResource(\r\n    resourceName,\r\n    \"REFRESH\",\r\n    collectionQuery\r\n  );\r\n  delete filterSafe.collectionQuery;\r\n  log(\"apiGetManyReference\", { resourceName, resource: r, params });\r\n  const data = r.list;\r\n  const targetField = params.target;\r\n  const targetValue = params.id;\r\n  let softDeleted = data;\r\n  if (options.softDelete) {\r\n    softDeleted = data.filter(doc => !doc['deleted'])\r\n  }\r\n  const filteredData = filterArray(softDeleted, filterSafe);\r\n  const targetIdFilter = {} as any;\r\n  targetIdFilter[targetField] = targetValue;\r\n  const permittedData = filterArray(filteredData, targetIdFilter);\r\n  if (params.sort != null) {\r\n    const { field, order } = params.sort;\r\n    if (order === \"ASC\") {\r\n      sortArray(permittedData, field, \"asc\");\r\n    } else {\r\n      sortArray(permittedData, field, \"desc\");\r\n    }\r\n  }\r\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\r\n  const pageEnd = pageStart + params.pagination.perPage;\r\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\r\n  const total = permittedData.length;\r\n\r\n  if (options.relativeFilePaths) {\r\n    const data = await Promise.all(\r\n      permittedData.map((doc) =>\r\n        recursivelyMapStorageUrls(fireWrapper, doc)\r\n      )\r\n    );\r\n    return { data, total };\r\n  }\r\n\r\n  return { data: dataPage, total };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\n\r\nexport async function Update<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.UpdateParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateResult<T>> {\r\n  const { rm } = client;\r\n  log(\"Update\", { resourceName, params });\r\n  const id = params.id + \"\";\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"Update\", { resourceName, resource: r, params });\r\n  const data = await client.parseDataAndUpload(r, id, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, id);\r\n  await client.addUpdatedByFields(docObj);\r\n  await r.collection.doc(id).update(docObj);\r\n  return {\r\n    data: {\r\n      ...data,\r\n      id: id,\r\n    },\r\n  };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\n\r\nexport async function UpdateMany(\r\n  resourceName: string,\r\n  params: ra.UpdateManyParams,\r\n  client: FireClient\r\n): Promise<ra.UpdateManyResult> {\r\n  const { rm } = client;\r\n  log(\"UpdateMany\", { resourceName, params });\r\n  delete params.data.id;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"UpdateMany\", { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async id => {\r\n      const idStr = id+'';\r\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\r\n      const docObj = { ...data };\r\n      client.checkRemoveIdField(docObj, idStr);\r\n      await client.addUpdatedByFields(docObj);\r\n      await r.collection\r\n        .doc(idStr)\r\n        .update(docObj);\r\n      return {\r\n        ...data,\r\n        id: idStr\r\n      };\r\n    })\r\n  );\r\n  return {\r\n    data: returnData\r\n  };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\n\r\nexport async function Create<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.CreateParams,\r\n  client: FireClient\r\n): Promise<ra.CreateResult<T>> {\r\n  const { rm, fireWrapper } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"Create\", { resourceName, resource: r, params });\r\n  const hasOverridenDocId = params.data && params.data.id;\r\n  log(\"Create\", { hasOverridenDocId });\r\n  if (hasOverridenDocId) {\r\n    const overridenId = params.data.id;\r\n    const exists = (await r.collection.doc(overridenId).get()).exists;\r\n    if (exists) {\r\n      throw new Error(\r\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\r\n      );\r\n    }\r\n    const data = await client.parseDataAndUpload(r, overridenId, params.data);\r\n    if (!overridenId) {\r\n      throw new Error(\"id must be a valid string\");\r\n    }\r\n    const docObj = { ...data };\r\n    client.checkRemoveIdField(docObj, overridenId);\r\n    await client.addCreatedByFields(docObj);\r\n    await client.addUpdatedByFields(docObj);\r\n    log(\"Create\", { docObj });\r\n    await r.collection.doc(overridenId).set(docObj, { merge: false });\r\n    return {\r\n      data: {\r\n        ...data,\r\n        id: overridenId,\r\n      },\r\n    };\r\n  }\r\n  const newId = fireWrapper.db().collection(\"collections\").doc().id;\r\n  const data = await client.parseDataAndUpload(r, newId, params.data);\r\n  const docObj = { ...data };\r\n  client.checkRemoveIdField(docObj, newId);\r\n  await client.addCreatedByFields(docObj);\r\n  await client.addUpdatedByFields(docObj);\r\n  await r.collection.doc(newId).set(docObj, { merge: false });\r\n  return {\r\n    data: {\r\n      ...data,\r\n      id: newId,\r\n    },\r\n  };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\nimport { DeleteSoft } from \"./Delete.Soft\";\r\n\r\nexport async function Delete<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm, options } = client;\r\n  if (options.softDelete) {\r\n    return DeleteSoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"apiDelete\", { resourceName, resource: r, params });\r\n  try {\r\n    const id = params.id + \"\";\r\n    await r.collection.doc(id).delete();\r\n  } catch (error) {\r\n    throw new Error(error);\r\n  }\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log, logError } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\n\r\nexport async function DeleteSoft<T extends ra.Record>(\r\n  resourceName: string,\r\n  params: ra.DeleteParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteResult<T>> {\r\n  const { rm } = client;\r\n  const id = params.id + \"\";\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"DeleteSoft\", { resourceName, resource: r, params });\r\n  const docObj = { deleted: true };\r\n  await client.addUpdatedByFields(docObj);\r\n  r.collection\r\n    .doc(id)\r\n    .update(docObj)\r\n    .catch((error) => {\r\n      logError(\"DeleteSoft error\", { error });\r\n    });\r\n  return {\r\n    data: params.previousData as T,\r\n  };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\nimport { DeleteManySoft } from \"./DeleteMany.Soft\";\r\n\r\ntype DocumentRef = firebase.firestore.DocumentReference<any>;\r\n\r\nexport async function DeleteMany(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { options, rm, fireWrapper } = client;\r\n  if (options.softDelete) {\r\n    return DeleteManySoft(resourceName, params, client);\r\n  }\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"DeleteMany\", { resourceName, resource: r, params });\r\n  const returnData: ra.Identifier[] = [];\r\n  const batch = fireWrapper.db().batch();\r\n  for (const id of params.ids) {\r\n    const idStr = id + '';\r\n    const docToDelete = r.collection.doc(idStr) as DocumentRef;\r\n    batch.delete(docToDelete);\r\n    returnData.push(id);\r\n  }\r\n  try {\r\n    await batch.commit();\r\n  } catch (error) {\r\n    throw new Error(error)\r\n  }\r\n  return { data: returnData };\r\n}\r\n","import { FireClient } from \"../database/FireClient\";\r\nimport { log, logError } from \"../../misc\";\r\nimport * as ra from \"../../misc/react-admin-models\";\r\n\r\nexport async function DeleteManySoft(\r\n  resourceName: string,\r\n  params: ra.DeleteManyParams,\r\n  client: FireClient\r\n): Promise<ra.DeleteManyResult> {\r\n  const { rm } = client;\r\n  const r = await rm.TryGetResource(resourceName);\r\n  log(\"DeleteManySoft\", { resourceName, resource: r, params });\r\n  const ids = params.ids;\r\n  const returnData = await Promise.all(\r\n    ids.map(async (id) => {\r\n      const idStr = id + \"\";\r\n      const docObj = { deleted: true };\r\n      await client.addUpdatedByFields(docObj);\r\n      r.collection\r\n        .doc(idStr)\r\n        .update(docObj)\r\n        .catch((error) => {\r\n          logError(\"apiSoftDeleteMany error\", { error });\r\n        });\r\n      return idStr;\r\n    })\r\n  );\r\n  return {\r\n    data: returnData,\r\n  };\r\n}\r\n"],"names":["parseAllDatesDoc","obj","Object","keys","map","key","recusivelyCheckObjectValue","input","toDate","Array","isArray","value","parseFireStoreDocument","doc","data","id","sortArray","field","dir","sort","a","b","rawA","get","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","fieldName","getSubObjects","searchField","searchValue","tree","leaves","recursivelyWalk","path","hasOwnProperty","objVal","currentPath","push","objectFlatten","getFieldReferences","filter","row","reduce","acc","cur","searchThis","toString","includes","doesRowMatch","LogNoOp","LoggerBase","title","cacheEnabledKey","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","console","log","bind","warn","error","logger","logError","logWarn","KEY_SINGLE","s","then","pact","_Pact","result","state","_settle","onRejected","recursivelyMapStorageUrls","fireWrapper","fieldValue","isObject","isFileField","src","startsWith","ref","storage","getDownloadURL","_exit2","i","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","length","slice","joinPaths","FirebaseWrapper","GetApp","app","init","firebaseConfig","options","optionsSafe","firebase","apps","initializeApp","ObtainFirebaseApp","firestore","db","serverTimestamp","auth","GetUserLogin","Promise","resolve","reject","_this2","onAuthStateChanged","user","OnUserLogout","callBack","isLoggedOut","ResourceManager","flogger","_this","resources","TryGetResource","resourceName","refresh","collectionQuery","TryGetResourcePromise","_this3","RefreshResource","GetResource","resource","_this5","initPath","_this7","_this7$options","lazyLoading","_this7$options$lazyLo","enabled","collection","query","applyQuery","newDocs","list","docs","logDocument","collectionPath","GetSingleDoc","docId","_this9","docSnap","exists","absolutePath","hasBeenInited","pathAbsolute","allResources","getUserIdentifier","_this13","associateUsersById","getCurrentUserEmail","identifier","getCurrentUserId","email","uid","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","parseDataAndUpload","r","docPath","uploads","recusivelyParseObjectValue","fieldPath","index","fieldDotsPath","fieldSlashesPath","rawFile","parseDocGetAllUploads","all","u","uploadAndGetLink","useFileNamesInStorage","link","set","addCreatedByFields","disableMeta","currentUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","addUpdatedByFields","updateAtSelector","updated_at","GetSelectorsUpdateAt","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","useFileName","storagePath","name","saveFile","task","_this10","put","res","rej","taskResult","relativeFilePaths","storageError","code","callback","v","thenable","getQueryCursor","params","btoa","JSON","stringify","paramsToQuery","defaultParamsToQueryOptions","filtersStepQuery","filters","forEach","where","sortStepQuery","parsedOrder","order","toLocaleLowerCase","orderBy","sortToQuery","pagination","page","perPage","queryCursor","startAfter","limit","queryBase","currentPage","newQuery","startAt","lastQueryCursor","snapshots","docsLength","currentPageParams","findLastQueryCursor","paginationToQuery","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","array","FirebaseLazyLoadingClient","client","apiGetList","tryGetResource","softDelete","resultsCount","message","total","nextPageCursor","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","checkIfOnLastPage","isOnLastPage","parsedData","apiGetManyReference","_this4","filterWithTarget","target","nextElementSnapshot","empty","clearQueryCursors","cursor","AuthClient","optionsInput","persistence","setPersistence","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","HandleAuthLogin","username","password","signInWithEmailAndPassword","getUserLogin","HandleAuthLogout","signOut","HandleAuthError","errorHttp","status","retrieveStatusTxt","HandleAuthCheck","currentUser","unsubscribe","HandleGetPermissions","getIdTokenResult","token","claims","e","HandleGetIdentity","displayName","photoURL","fullName","avatar","HandleGetJWTAuthTime","_this11","authTime","HandleGetJWTExpirationTime","expirationTime","HandleGetJWTSignInProvider","_this15","signInProvider","HandleGetJWTIssuedAtTime","_this17","issuedAtTime","HandleGetJWTToken","_this19","VerifyAuthProviderArgs","logging","login","logout","checkAuth","checkError","getPermissions","getIdentity","getAuthUser","getJWTAuthTime","getJWTExpirationTime","getJWTSignInProvider","getJWTClaims","getJWTToken","run","cb","errorMsg","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","verifyDataProviderArgs","ResetCount","shouldReset","docCount","_options$lazyLoading","count","incrementBy","currentCountRaw","incremented","parseInt","incrementRead","MakeFirestoreLogger","firestoreCostsLogger","_options$firestoreCos","_options$firestoreCos2","persistCount","getList","lazyClient","filterSafe","dataPage","softDeleted","filteredData","pageStart","GetList","getOne","dataSingle","GetOne","getMany","ids","matchDocSnaps","permittedData","matches","snap","GetMany","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","docObj","Update","updateMany","idStr","returnData","UpdateMany","create","newId","merge","hasOverridenDocId","overridenId","_r$collection$doc$get","Create","previousData","DeleteSoft","Delete","deleteMany","DeleteManySoft","batch","docToDelete","commit","DeleteMany"],"mappings":"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"}